<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    
    function Person(name, age, job) { // 按照惯例，构造函数始终以一个大写字母开头，即Person
      this.name = name;
      this.age = age;
      this.job = job;
      this.sayName = function () {
        console.log(this.name);
      }
    }
    var person1 = new Person("Alan", 21, "coder");
    var person2 = new Person("Mary", 20, "painter");
    // 每个方法都要在每个实例上重新创建一遍
    console.log(person1.sayName == person2.sayName); //false

    // 可以通过把函数sayName放到构造函数外面来实现
    function Person1(name, age, job){
      this.name = name;
      this.age = age;
      this.job = job;
      this.sayName = sayName;
    }
    function sayName(){
      alert(this.name);
    }
    var person3 = new Person1("Nicholas", 29, "Software Engineer");
    var person4 = new Person1("Greg", 27, "Doctor");
    console.log(person3.sayName == person4.sayName); // true

    // 但是这样做如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了
    // 但是可以使用原型模式来解决这个问题
    
  </script>
</body>
</html>